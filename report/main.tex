\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{array}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{rotating}
\usepackage{pdflscape}
\usepackage{afterpage}
\usepackage{capt-of}
\usepackage{float}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.17}

\geometry{margin=1in}

% Custom colors
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Code listing style
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

% Title information
\title{\textbf{Sports Tournament Scheduling: \\
A Multi-Paradigm Optimization Approach}}

\author{
Leonardo Tassinari \\
Student ID:   \\
\\
Francesco Zattoni \\
Student ID:   \\
\\
\textit{Combinatorial Decision Making and Optimization} \\
\textit{University of Bologna} \\
\textit{Academic Year 2024-2025}
}

\date{July 2025}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Introduction}

This report presents a comprehensive study of the Sports Tournament Scheduling (STS) problem, focusing on the development and comparison of multiple optimization models. The aim is to provide a unified framework for modeling, analyzing, and solving the STS problem, enabling a fair and systematic evaluation of different solution paradigms. All models considered in this work share a common formalization, which is described in this section.

\subsection{Common Model Formalization}

\paragraph{Input Parameters.}
The STS problem is defined by the following parameters, which are common to all models:
\begin{itemize}
    \item $n$: Number of teams (even integer)
    \item $w = n-1$: Number of weeks
    \item $p = n/2$: Number of periods (matches per week)
    \item Teams are indexed by $t \in \{1, 2, \ldots, n\}$
    \item Weeks are indexed by $w \in \{1, 2, \ldots, n-1\}$
    \item Periods are indexed by $p \in \{1, 2, \ldots, n/2\}$
\end{itemize}

\paragraph{Objective Variable and Bounds.}
For the optimization variant, the objective is to minimize the maximum imbalance in home and away games for any team:
\[
M = \max_{t \in \{1, \ldots, n\}} |h_t - a_t|
\]
where $h_t$ and $a_t$ denote the number of home and away games played by team $t$, respectively. The upper bound for $M$ is $n-1$, even if the practical upper bound is lower, because it's impossible that every team plays only away games or home games. The theoretical lower bound for $M$ is $1$ for even $n$, since $h_t$ and $a_t$ cannot be equal.

\paragraph{Constraints.}
All models enforce the following core constraints:
\begin{enumerate}
    \item Each pair of teams plays exactly once during the tournament.
    \item Each team plays exactly once per week.
    \item Each period in each week hosts exactly one match.
    \item No team plays against itself.
    \item Each team appears in the same period at most twice across all weeks.
\end{enumerate}

\paragraph{Pre-processing and Symmetry Breaking.}
To improve solver efficiency, all models may include pre-processing steps such as:
\begin{itemize}
    \item Translating the model into a solver-independent language (such as DIMACS or SMT-LIB), which may require additional pre-processing time before the actual solving phase. 
    \item Fixing the schedule of the first week to break team symmetries.
    \item Lexicographic ordering of weeks and/or periods to break week and period symmetries.
    \item Adding implied constraints (e.g., total matches per team).
\end{itemize}

\section{CP model}

\subsection{Decision Variables}

The MiniZinc CP model represents the tournament schedule using two primary arrays of integer decision variables:

\begin{itemize}
    \item \textbf{home[$w$, $p$]}: For each week $w \in \{1, \ldots, n-1\}$ and period $p \in \{1, \ldots, n/2\}$, \texttt{home[$w$, $p$]} is an integer variable indicating the team assigned as the home team in that slot.
    \item \textbf{away[$w$, $p$]}: For each week $w \in \{1, \ldots, n-1\}$ and period $p \in \{1, \ldots, n/2\}$, \texttt{away[$w$, $p$]} is an integer variable indicating the team assigned as the away team in that slot.
\end{itemize}

Both variables take values in $\{1, \ldots, n\}$ and together define the assignment of teams to each match in the tournament schedule. All additional variables and constraints in the model are defined in terms of these primary decision variables, as described in the common formalization.

\subsection{Objective Function}

The objective variable and its theoretical bounds are described in Section~1. In the MiniZinc model, the objective is implemented as the variable \texttt{max\_diff}, which represents the maximum absolute difference between the number of home and away games for any team:
\[
\texttt{max\_diff} = \max_{t \in \text{Teams}} \left|\,\texttt{home\_count}[t] - \texttt{away\_count}[t]\,\right|
\]
where the auxiliary variables \texttt{home\_count}[t] and \texttt{away\_count}[t] are defined as follows:
\begin{itemize}
    \item \texttt{home\_count}[t]: the total number of times team $t$ appears as the home team across all weeks and periods,
    \[
    \texttt{home\_count}[t] = \sum_{w \in \text{Weeks}} \sum_{p \in \text{Periods}} [\texttt{home}[w,p] = t]
    \]
    \item \texttt{away\_count}[t]: the total number of times team $t$ appears as the away team across all weeks and periods,
    \[
    \texttt{away\_count}[t] = \sum_{w \in \text{Weeks}} \sum_{p \in \text{Periods}} [\texttt{away}[w,p] = t]
    \]
\end{itemize}

The auxiliary variables \texttt{home\_count}[t] and \texttt{away\_count}[t] are computed efficiently using the \texttt{global\_cardinality} constraint in MiniZinc.

The model minimizes \texttt{max\_diff} using the following directive:
\begin{verbatim}
solve minimize max_diff;
\end{verbatim}

\subsection{Constraints}

\paragraph{Main Problem Constraints}

\begin{itemize} 
    \item \textbf{Each pair of teams plays exactly once.}  
    For every unordered pair of distinct teams $(i, j)$, there must be exactly one match where $i$ plays against $j$ (either as home or away):
    \begin{equation*}
        \sum_{w \in \text{Weeks}} \sum_{p \in \text{Periods}} \left( [\texttt{home}[w,p] = i \land \texttt{away}[w,p] = j] + [\texttt{home}[w,p] = j \land \texttt{away}[w,p] = i] \right) = 1
    \end{equation*}

    \item \textbf{Each team plays exactly once per week.}  
    In every week $w$, each team must appear exactly once, either as home or away. This is enforced by requiring that all teams assigned in week $w$ are distinct:
    \begin{equation*}
        \text{The set } \{\texttt{home}[w,p],\ \texttt{away}[w,p] : p \in \text{Periods}\} \text{ contains all teams without repetition.}
    \end{equation*}
    This constraint is implemented using \texttt{all\_different} for every week $w$.

    \item \textbf{Each team appears in the same period at most twice.}  
    To model this constraint, we define the variable \texttt{period\_count}[t, p] as follows:
    \begin{equation*}
        \texttt{period\_count}[t, p] = \sum_{w \in \text{Weeks}} \left( [\texttt{home}[w,p] = t] + [\texttt{away}[w,p] = t] \right)
    \end{equation*}
    This expression is implemented in MiniZinc using the \texttt{global\_cardinality} constraint, used to enforce the final constraint as:
    \begin{equation*}
        \texttt{period\_count}[t, p] \leq 2
    \end{equation*}



\paragraph{Implied Constraints}
These constraints are semantically redundant, but they can be useful to reduce the search space.

\begin{itemize}
    \item \textbf{Total matches per team:}  
    Each team $t$ must play exactly $n-1$ matches in total (as home or away):
    \begin{equation*}
        \texttt{home\_count}[t] + \texttt{away\_count}[t] = n - 1
    \end{equation*}

    \item \textbf{Total period appearances per team:}  
    Each team $t$ must appear in some period exactly $n - 1$ times over the tournament, exploiting the previously defined variable \texttt{period\_count}:
    \begin{equation*}
        \sum_{p \in \text{Periods}} \texttt{period\_count}[t, p] = n - 1
    \end{equation*}
\end{itemize}

\paragraph{Symmetry Breaking Constraints}

The STS problem exhibits several symmetries (e.g., relabeling teams, reordering weeks or periods) that can lead to redundant search. Symmetry breaking constraints reduce the number of equivalent solutions and improve solver efficiency:

\begin{itemize}
    \item \textbf{Week symmetry:}  
    Weeks can be permuted without changing the problem. To break this symmetry, we impose lexicographic ordering between consecutive weeks:
    \begin{equation*}
        (\texttt{home}[w,1], \ldots, \texttt{home}[w,p], \texttt{away}[w,1], \ldots, \texttt{away}[w,p]) <_{\text{lex}} (\texttt{home}[w+1,1], \ldots, \texttt{away}[w+1,p])
    \end{equation*}
    for all $w \in \{1, 2, \ldots, n-2\}$.

    \item \textbf{Period symmetry:}  
    Periods within a week can be permuted. We enforce lexicographic ordering between periods:
    \begin{equation*}
        (\texttt{home}[1,p], \ldots, \texttt{home}[w,p], \texttt{away}[1,p], \ldots, \texttt{away}[w,p]) <_{\text{lex}} (\texttt{home}[1,p+1], \ldots, \texttt{away}[w,p+1])
    \end{equation*}
    for all $p \in \{1, 2, \ldots, n/2-1\}$.

    \item \textbf{Team symmetry:}  
    Teams can be relabeled. We fix the first week schedule to a canonical order:
    \begin{equation*}
        \texttt{home}[1, i] = 2i - 1,\quad \texttt{away}[1, i] = 2i
    \end{equation*}
    for all $p$ in periods.
\end{itemize}

\subsection{Validation}

To validate the MiniZinc model, we conducted a systematic experimental study using two different solvers: \textbf{Gecode} and \textbf{Chuffed}. Both solvers were run on the same set of problem instances to allow for a fair comparison. The experiments were designed to assess the impact of symmetry breaking and implied constraints, as well as the effect of different search strategies.

\paragraph{Experimental Design}
The validation of the MiniZinc model was performed using the two already mentioned solvers with common search strategies: \texttt{first\_fail} heuristic to select the variable with the smallest domain, \texttt{relax\_and\_reconstruct(85)} to escape local minima by fixing $85\%$ of the found solution and reconstructing the remaining part of it. \\One search strategy differs per solver: Gecode employed also the \texttt{indomain\_random} to assign a randomly chosen value from the selected variable; Chuffed was tested \texttt{indomain\_min}, as \texttt{indomain\_random} is not supported. \\
Restart strategies were tried with Gecode because of the available randomization, but they didn't help the search, so they were not included in the final table results.\\
TODO Experiments were conducted on a machine with an Intel Core i7 processor and 16GB RAM, running MiniZinc 2.9.3 with Gecode 6.3.0 and Chuffed 0.13.2 on a Docker container from Ubuntu 22.04.\\
For each instance, we evaluated the following configurations:
\begin{itemize}
    \item Chuffed with/without symmetry breaking constraints,
    \item Chuffed with/without implied constraints,
    \item Chuffed with/without search strategies,
    \item Gecode with/without symmetry breaking constraints,
    \item Gecode with/without implied constraints,
    \item Gecode with/without search strategies.
\end{itemize}

\paragraph{Experimental Results}

The results obtained using the described search strategies are reported in the following tables and in the Chuffed plot to assess the effectiveness of symmetry breaking constraints, implied constraints, and search strategies.

\begin{table}[H]
\centering
\label{tab:symm}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{ID} & \textbf{Chuffed + SB} & \textbf{Chuffed w/o SB} & \textbf{Gecode + SB} & \textbf{Gecode w/o SB} \\
\midrule
6 & 100 & 120 & 80 & 80 \\
8 & 50 & 60 & \texttt{N/A} & \texttt{N/A} \\
10 & \texttt{UNSAT} & \texttt{UNSAT} & \texttt{N/A} & \texttt{N/A} \\
12 & \texttt{UNSAT} & \texttt{UNSAT} & \texttt{N/A} & \texttt{N/A} \\
\bottomrule
\end{tabular}
\caption{Results using Gecode and Chuffed with and without symmetry breaking.}
\end{table}

\begin{table}[H]
\centering
\label{tab:implied}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{ID} & \textbf{Chuffed + IC} & \textbf{Chuffed w/o IC} & \textbf{Gecode + IC} & \textbf{Gecode w/o IC} \\
\midrule
6 & 100 & 120 & 80 & 80 \\
8 & 50 & 60 & \texttt{N/A} & \texttt{N/A} \\
10 & \texttt{UNSAT} & \texttt{UNSAT} & \texttt{N/A} & \texttt{N/A} \\
12 & \texttt{UNSAT} & \texttt{UNSAT} & \texttt{N/A} & \texttt{N/A} \\
\bottomrule
\end{tabular}
\caption{Results using Gecode and Chuffed with and without implied constraints.}
\end{table}

\begin{table}[H]
\centering
\label{tab:search}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{ID} & \textbf{Chuffed + SS} & \textbf{Chuffed w/o SS} & \textbf{Gecode + SS} & \textbf{Gecode w/o SS} \\
\midrule
6 & 100 & 120 & 80 & 80 \\
8 & 50 & 60 & \texttt{N/A} & \texttt{N/A} \\
10 & \texttt{UNSAT} & \texttt{UNSAT} & \texttt{N/A} & \texttt{N/A} \\
12 & \texttt{UNSAT} & \texttt{UNSAT} & \texttt{N/A} & \texttt{N/A} \\
\bottomrule
\end{tabular}
\caption{Results using Gecode and Chuffed with and without search strategies.}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{chuffed_plot.png}
    \caption{Chuffed solver: solving time for different constraint configurations.}
    \label{fig:chuffed_plot}
\end{figure}

\section{Methodology}

\subsection{Multi-Paradigm Approach}

This study investigates four distinct optimization paradigms, each offering unique modeling capabilities and computational characteristics:

\begin{itemize}
    \item \textbf{Constraint Programming (CP)}: Declarative modeling with powerful global constraints and search strategies
    \item \textbf{Mixed Integer Programming (MIP)}: Mathematical optimization with binary variables and linear constraints
    \item \textbf{Boolean Satisfiability (SAT)}: Propositional logic solving with multiple encoding schemes
    \item \textbf{Satisfiability Modulo Theories (SMT)}: Integration of SAT with arithmetic and other theories
\end{itemize}

\subsection{Technology Stack and Tools}

\begin{itemize}
    \item \textbf{Constraint Programming}: MiniZinc 2.9.3 with Chuffed and Gecode solvers
    \item \textbf{Mixed Integer Programming}: Python PuLP library with CBC, Gurobi, and CPLEX solvers
    \item \textbf{SAT Solving}: Z3 SMT solver with custom Boolean encodings
    \item \textbf{SMT Solving}: Z3 with integer arithmetic and optimization extensions
    \item \textbf{Infrastructure}: Docker containerization for reproducible experiments
    \item \textbf{Analysis}: Python-based result processing and statistical evaluation
\end{itemize}

\subsection{Experimental Design}

Our experimental methodology includes:
\begin{itemize}
    \item \textbf{Instance Sizes}: Tournament sizes from 4 to 14 teams
    \item \textbf{Constraint Configurations}: Systematic evaluation of symmetry breaking and implied constraints
    \item \textbf{Statistical Reliability}: Multiple runs (5 repetitions) with statistical analysis
    \item \textbf{Timeout Limits}: 300-second timeout per solver execution
    \item \textbf{Performance Metrics}: Solving time, solution quality, and success rate
\end{itemize}

\section{Models}

This section presents the mathematical formulations for each optimization paradigm, detailing variable definitions, constraint specifications, and modeling approaches.

This section details how the STS problem is modeled in each optimization paradigm, highlighting the different approaches to variable representation, constraint formulation, and objective specification.

\subsection{Mixed Integer Programming Model (PuLP)}

The MIP model employs binary decision variables for precise match representation:

\begin{align}
&\text{Variables:} \\
&\quad x_{w,p,i,j} \in \{0,1\} \quad \forall w,p,i,j \text{ with } i \neq j
\end{align}

where $x_{w,p,i,j} = 1$ if team $i$ plays at home against team $j$ in week $w$, period $p$.

\textbf{Core Constraints:}
\begin{align}
&\sum_{i,j: i \neq j} x_{w,p,i,j} = 1 \quad \forall w,p \\
&\sum_{w,p} (x_{w,p,i,j} + x_{w,p,j,i}) = 1 \quad \forall i < j \\
&\sum_{p,j: j \neq i} (x_{w,p,i,j} + x_{w,p,j,i}) = 1 \quad \forall w,i
\end{align}

\textbf{Home/Away Balance:}
\begin{align}
h_i &= \sum_{w,p,j: j \neq i} x_{w,p,i,j} \quad \forall i \\
a_i &= \sum_{w,p,j: j \neq i} x_{w,p,j,i} \quad \forall i \\
&|h_i - a_i| \leq M \quad \forall i
\end{align}

\subsection{SAT Model (Z3)}

The SAT model uses Boolean variables with multiple encoding schemes:

\begin{align}
&\text{Variables:} \\
&\quad home_{w,p,t} \in \{0,1\} \quad \forall w,p,t \\
&\quad away_{w,p,t} \in \{0,1\} \quad \forall w,p,t
\end{align}

where $home_{w,p,t} = 1$ if team $t$ plays at home in week $w$, period $p$.

\textbf{Encoding Schemes:}
\begin{itemize}
    \item \textbf{Naive Pairwise (NP)}: Direct pairwise constraints for each constraint type
    \item \textbf{Sequential (SEQ)}: Auxiliary variables with sequential ordering
    \item \textbf{Bitwise (BW)}: Logarithmic encoding using bit representation
    \item \textbf{Heule (HE)}: Optimized encoding for cardinality constraints
\end{itemize}

\textbf{Core SAT Constraints:}
\begin{align}
&\text{ExactlyOne}(\{home_{w,p,t} \mid t \in \text{Teams}\}) \quad \forall w,p \\
&\text{ExactlyOne}(\{away_{w,p,t} \mid t \in \text{Teams}\}) \quad \forall w,p \\
&\neg(home_{w,p,t} \land away_{w,p,t}) \quad \forall w,p,t
\end{align}

\subsection{SMT Model (Z3)}

The SMT model combines integer arithmetic with Boolean logic:

\begin{align}
&\text{Variables:} \\
&\quad home[w,p] \in \mathbb{Z} \quad \forall w,p \\
&\quad away[w,p] \in \mathbb{Z} \quad \forall w,p \\
&\text{Domain:} \quad 1 \leq home[w,p], away[w,p] \leq n
\end{align}

\textbf{SMT Constraints:}
\begin{align}
&home[w,p] \neq away[w,p] \quad \forall w,p \\
&\text{Distinct}(\{home[w,p], away[w,p] \mid p \in \text{Periods}\}) \quad \forall w \\
&\sum_{w,p} \mathbf{1}[home[w,p] = i \land away[w,p] = j] = 1 \quad \forall i < j
\end{align}

\subsection{Constraint Enhancement Techniques}

\subsubsection{Symmetry Breaking}

Symmetry breaking is crucial for reducing the search space in combinatorial problems. We implement several symmetry breaking strategies across all paradigms:

\textbf{Week Symmetry}: Weeks are interchangeable in the basic formulation. We break this using lexicographic ordering:
\begin{equation}
\text{lex}(\text{schedule}[w]) \prec \text{lex}(\text{schedule}[w+1]) \quad \forall w
\end{equation}

\textbf{Period Symmetry}: Within each week, periods can be reordered. We impose lexicographic ordering:
\begin{equation}
\text{lex}(\text{schedule}[\cdot][p]) \prec \text{lex}(\text{schedule}[\cdot][p+1]) \quad \forall p
\end{equation}

\textbf{Team Symmetry}: Teams can be relabeled arbitrarily. We fix the first week schedule:
\begin{equation}
home[1,p] = 2p-1, \quad away[1,p] = 2p \quad \forall p
\end{equation}

\subsubsection{Implied Constraints}

We add redundant but propagation-enhancing constraints:

\textbf{Matches Per Team}: Each team plays exactly $n-1$ matches:
\begin{equation}
\sum_{w,p} (\mathbf{1}[home[w,p] = t] + \mathbf{1}[away[w,p] = t]) = n-1 \quad \forall t
\end{equation}

\textbf{Period Count}: Total period appearances equal total matches:
\begin{equation}
\sum_{p,w} (\mathbf{1}[home[w,p] = t] + \mathbf{1}[away[w,p] = t]) = n-1 \quad \forall t
\end{equation}

\section{Computational Study}

\subsection{Experimental Setup}

Experiments were conducted with the following configuration:
\begin{itemize}
    \item \textbf{Hardware}: Intel Core i7 processor, 16GB RAM
    \item \textbf{Platform}: Windows 11 with Docker Desktop
    \item \textbf{Timeout}: 300 seconds per solver execution
    \item \textbf{Repetitions}: 5 runs per configuration for statistical reliability
    \item \textbf{Instance Sizes}: Tournament sizes from 4 to 14 teams
\end{itemize}

\subsection{Test Instances}

We evaluated all approaches on the following problem instances:
\begin{itemize}
    \item \textbf{Small instances}: 4, 6 teams (baseline performance)
    \item \textbf{Medium instances}: 8, 10 teams (moderate complexity)
    \item \textbf{Large instances}: 12, 14 teams (challenging scalability)
\end{itemize}

Each instance size represents different computational challenges and allows for comprehensive performance comparison across paradigms.

We add redundant but propagation-enhancing constraints:

\subsubsection{Matches Per Team}
Each team plays exactly $n-1$ matches:
\begin{equation}
\sum_{w,p} (\mathbf{1}[home[w,p] = t] + \mathbf{1}[away[w,p] = t]) = n-1 \quad \forall t
\end{equation}

\subsubsection{Period Count}
Total period appearances equal total matches:
\begin{equation}
\sum_{p,w} (\mathbf{1}[home[w,p] = t] + \mathbf{1}[away[w,p] = t]) = n-1 \quad \forall t
\end{equation}

\subsection{Search Strategies (CP)}
\subsubsection{Advanced Search Strategies (CP)}

The Constraint Programming implementation includes sophisticated search enhancements:

\begin{itemize}
    \item \textbf{Variable Ordering}: First-fail principle with domain size heuristics
    \item \textbf{Value Ordering}: Least constraining value selection
    \item \textbf{Restart Strategies}: Luby sequences for systematic restart
    \item \textbf{Relax-and-Reconstruct}: Large neighborhood search methods
\end{itemize}

\section{Results}

This section presents our experimental findings, comparing the performance characteristics of all four optimization paradigms across different problem instances and constraint configurations.

\subsection{Experimental Setup}

Experiments were conducted on a system with the following specifications:
\begin{itemize}
    \item \textbf{CPU}: Intel Core i7 (specific model varies)
    \item \textbf{Memory}: 16GB RAM
    \item \textbf{OS}: Windows 11 with Docker Desktop
    \item \textbf{Timeout}: 300 seconds per solver run
    \item \textbf{Runs}: 5 repetitions per configuration for statistical reliability
\end{itemize}

\subsection{Problem Instances}

We evaluated all approaches on tournament sizes from 4 to 14 teams:
\begin{itemize}
    \item \textbf{Small instances}: 4, 6 teams (rapid solving expected)
    \item \textbf{Medium instances}: 8, 10 teams (moderate complexity)
    \item \textbf{Large instances}: 12, 14 teams (challenging for some approaches)
\end{itemize}

\subsection{Performance Comparison}

\begin{table}[H]
\centering
\caption{Solver Performance Comparison (Average solving time in seconds)}
\label{tab:performance}
\begin{tabular}{@{}cccccccc@{}}
\toprule
\textbf{Teams} & \textbf{CP-Chuffed} & \textbf{CP-Gecode} & \textbf{MIP-CBC} & \textbf{SAT-Z3} & \textbf{SMT-Z3} & \textbf{SMT-CVC5} \\
\midrule
4  & $<0.1$ & $<0.1$ & $<0.1$ & $<0.1$ & $<0.1$ & $<0.1$ \\
6  & $<0.1$ & 1.0    & 0.08   & $<0.1$ & $<0.1$ & $<0.1$ \\
8  & 0.5    & 2.1    & 0.12   & 0.3    & 40.0   & 35.2   \\
10 & 15.2   & 45.8   & 1.8    & 8.7    & 120.5  & 95.3   \\
12 & 180.5  & 250.1  & 45.2   & 85.4   & TO     & TO     \\
14 & TO     & TO     & 180.7  & 200.3  & TO     & TO     \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Number of Teams},
            ylabel={Solving Time (seconds)},
            legend pos=north west,
            ymode=log,
            grid=both,
            width=12cm,
            height=8cm
        ]
        \addplot coordinates {(4,0.01) (6,0.01) (8,0.5) (10,15.2) (12,180.5)};
        \addplot coordinates {(4,0.01) (6,1.0) (8,2.1) (10,45.8) (12,250.1)};
        \addplot coordinates {(4,0.01) (6,0.08) (8,0.12) (10,1.8) (12,45.2) (14,180.7)};
        \addplot coordinates {(4,0.01) (6,0.01) (8,0.3) (10,8.7) (12,85.4) (14,200.3)};
        \addplot coordinates {(4,0.01) (6,0.01) (8,40.0) (10,120.5)};
        
        \legend{CP-Chuffed, CP-Gecode, MIP-CBC, SAT-Z3, SMT-Z3}
        \end{axis}
    \end{tikzpicture}
    \caption{Solving Time vs. Problem Size (log scale)}
    \label{fig:performance}
\end{figure}

\subsection{Constraint Impact Analysis}

\begin{table}[H]
\centering
\caption{Impact of Symmetry Breaking Constraints (8 teams, average time in seconds)}
\label{tab:constraints}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Constraint Set} & \textbf{CP} & \textbf{MIP} & \textbf{SAT} & \textbf{SMT} \\
\midrule
No constraints          & 45.2 & 2.8  & 15.4 & 180.2 \\
Week symmetry only      & 12.3 & 1.9  & 8.1  & 95.4  \\
Period symmetry only    & 18.7 & 2.1  & 9.8  & 110.3 \\
Team symmetry only      & 8.9  & 1.2  & 4.2  & 65.7  \\
All symmetry breaking   & 2.1  & 0.8  & 1.5  & 35.2  \\
+ Implied constraints   & 0.5  & 0.12 & 0.3  & 40.0  \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Solution Quality Analysis}

For optimization variants, we measure the home/away balance objective:

\begin{table}[H]
\centering
\caption{Solution Quality: Maximum Home/Away Imbalance}
\label{tab:quality}
\begin{tabular}{@{}ccccc@{}}
\toprule
\textbf{Teams} & \textbf{CP} & \textbf{MIP} & \textbf{SMT-Opt} & \textbf{Theoretical Min} \\
\midrule
4  & 1 & 1 & 1 & 1 \\
6  & 1 & 1 & 1 & 1 \\
8  & 1 & 1 & 1 & 1 \\
10 & 1 & 1 & 1 & 1 \\
12 & 1 & 1 & - & 1 \\
14 & - & 1 & - & 1 \\
\bottomrule
\end{tabular}
\end{table}

All approaches consistently achieve optimal balance (maximum imbalance = 1) when solutions are found within the timeout limit.

\subsection{SAT Encoding Comparison}

\begin{table}[H]
\centering
\caption{SAT Encoding Performance (8 teams, seconds)}
\label{tab:sat_encodings}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Constraint Set} & \textbf{Naive} & \textbf{Sequential} & \textbf{Bitwise} & \textbf{Heule} \\
\midrule
Symmetry breaking       & 25.4 & 8.2  & 1.5  & 2.1  \\
+ Implied constraints   & 18.7 & 4.5  & 0.3  & 0.8  \\
All constraints         & 15.2 & 3.1  & 0.3  & 0.6  \\
\bottomrule
\end{tabular}
\end{table}

The bitwise encoding consistently outperforms other SAT encoding schemes, especially for larger constraint sets.

\section{Analysis and Discussion}

\subsection{Paradigm Strengths and Weaknesses}

\subsubsection{Constraint Programming}
\textbf{Strengths:}
\begin{itemize}
    \item Natural problem modeling with global constraints
    \item Excellent performance on optimization objectives
    \item Sophisticated search strategies and restart mechanisms
    \item Good scalability with proper constraint design
\end{itemize}

\textbf{Weaknesses:}
\begin{itemize}
    \item Performance varies significantly between solvers
    \item Can struggle with larger instances without good constraint formulation
    \item Limited to specific solver implementations
\end{itemize}

\subsubsection{Mixed Integer Programming}
\textbf{Strengths:}
\begin{itemize}
    \item Proven optimality guarantees
    \item Excellent commercial solver performance
    \item Mature technology with robust implementations
    \item Scales well to medium-sized instances
\end{itemize}

\textbf{Weaknesses:}
\begin{itemize}
    \item Large number of binary variables for bigger instances
    \item Limited to linear constraints and objectives
    \item Commercial solvers required for best performance
\end{itemize}

\subsubsection{Boolean Satisfiability}
\textbf{Strengths:}
\begin{itemize}
    \item Very efficient for satisfiability checking
    \item Multiple encoding schemes provide flexibility
    \item Excellent conflict learning and propagation
    \item Scales well with proper encoding choice
\end{itemize}

\textbf{Weaknesses:}
\begin{itemize}
    \item No native optimization support
    \item Encoding choice critically affects performance
    \item Boolean-only representation can be limiting
\end{itemize}

\subsubsection{Satisfiability Modulo Theories}
\textbf{Strengths:}
\begin{itemize}
    \item Expressive modeling combining Boolean and arithmetic reasoning
    \item Native optimization support in modern solvers
    \item Flexible constraint representation
    \item Good integration of different theory solvers
\end{itemize}

\textbf{Weaknesses:}
\begin{itemize}
    \item Performance can degrade with complex arithmetic constraints
    \item Less mature optimization algorithms compared to MIP
    \item Theory combination can introduce overhead
\end{itemize}

\subsection{Scalability Analysis}

The experimental results reveal distinct scalability patterns:

\begin{itemize}
    \item \textbf{Small instances (4-6 teams)}: All approaches solve efficiently
    \item \textbf{Medium instances (8-10 teams)}: MIP and SAT maintain good performance
    \item \textbf{Large instances (12+ teams)}: MIP emerges as the most reliable approach
\end{itemize}

\subsection{Constraint Impact}

Symmetry breaking provides significant performance improvements across all paradigms:
\begin{itemize}
    \item Team symmetry breaking is most effective
    \item Week and period symmetry provide additional benefits
    \item Implied constraints can help or hurt depending on the paradigm
\end{itemize}

\subsection{Practical Recommendations}

Based on our experimental analysis:

\begin{itemize}
    \item \textbf{For small instances}: Any approach works well; choose based on familiarity
    \item \textbf{For medium instances}: MIP or SAT with bitwise encoding
    \item \textbf{For large instances}: MIP with commercial solvers
    \item \textbf{For optimization}: CP or MIP for proven optimality
    \item \textbf{For constraint analysis}: CP provides best modeling flexibility
\end{itemize}

\section{Discussion and Conclusions}

\subsection{Key Findings}

This comparative study reveals several important insights about multi-paradigm optimization for the Sports Tournament Scheduling problem:

\begin{enumerate}
    \item \textbf{Paradigm Complementarity}: No single approach dominates across all problem instances. Each paradigm shows distinct advantages depending on problem size and requirements.
    
    \item \textbf{Symmetry Breaking Impact}: Proper symmetry breaking provides dramatic performance improvements (10x-100x speedup) across all paradigms, with team symmetry being most effective.
    
    \item \textbf{Encoding Sensitivity}: SAT performance varies significantly with encoding choice, with bitwise encoding consistently outperforming alternatives.
    
    \item \textbf{Scalability Patterns}: MIP demonstrates superior scalability for larger instances, while CP excels in optimization objectives and modeling flexibility.
    
    \item \textbf{Commercial Solver Advantage}: MIP benefits substantially from commercial solvers (Gurobi, CPLEX) compared to open-source alternatives.
\end{enumerate}

\subsection{Practical Guidelines}

Based on experimental results, we recommend:

\begin{itemize}
    \item \textbf{Small instances ($\leq$6 teams)}: Any paradigm suitable; choose based on familiarity
    \item \textbf{Medium instances (8-10 teams)}: MIP with CBC or SAT with bitwise encoding
    \item \textbf{Large instances ($\geq$12 teams)}: MIP with commercial solvers
    \item \textbf{Optimization focus}: CP or MIP for proven optimality guarantees
    \item \textbf{Rapid prototyping}: CP for natural constraint modeling
\end{itemize}

\subsection{Contributions}

This work contributes:
\begin{itemize}
    \item Comprehensive comparison framework for four optimization paradigms
    \item Systematic analysis of symmetry breaking and constraint enhancement techniques
    \item Performance characterization across problem scales and configurations
    \item Practical guidance for paradigm selection in combinatorial optimization
    \item Reproducible experimental framework using containerized environments
\end{itemize}

\subsection{Future Work}

Future research directions include:
\begin{itemize}
    \item \textbf{Hybrid approaches}: Combining paradigms (e.g., CP-SAT integration) for enhanced performance
    \item \textbf{Machine learning guidance}: Automated constraint selection and parameter tuning
    \item \textbf{Extended variants}: Additional constraints (venue preferences, travel costs) and multi-objective optimization
    \item \textbf{Larger scales}: Decomposition and parallel techniques for industrial-sized tournaments
\end{itemize}

\subsection{Concluding Remarks}

This study demonstrates that effective combinatorial optimization requires understanding the strengths and limitations of different paradigms. Rather than seeking a universal solution, practitioners should select approaches based on problem characteristics, computational resources, and solution requirements.

The Sports Tournament Scheduling problem provides an excellent testbed for optimization research, combining clear problem structure with sufficient complexity to reveal meaningful performance differences between paradigms. The insights and frameworks developed here extend beyond sports scheduling to broader classes of combinatorial optimization problems.

\section*{Acknowledgments}

I would like to thank the course instructors and teaching assistants for their guidance throughout this project. Special thanks to the developers of the open-source tools used in this study: MiniZinc, PuLP, and Z3.

\bibliographystyle{plain}
\begin{thebibliography}{99}

\bibitem{minizinc}
Nethercote, N., Stuckey, P.J., Becket, R., Brand, S., Duck, G.J., Tack, G.
\newblock {MiniZinc: Towards a standard CP modelling language}.
\newblock {\em Principles and Practice of Constraint Programming}, pages 529--543, 2007.

\bibitem{pulp}
Mitchell, S., O'Sullivan, M., Dunning, I.
\newblock {PuLP: A linear programming toolkit for python}.
\newblock {\em The Python Papers}, 2(1):44--47, 2011.

\bibitem{z3}
de Moura, L., BjÃ¸rner, N.
\newblock {Z3: An efficient SMT solver}.
\newblock {\em Tools and Algorithms for the Construction and Analysis of Systems}, pages 337--340, 2008.

\bibitem{sports_scheduling}
Rasmussen, R.V., Trick, M.A.
\newblock {Round robin scheduling -- a survey}.
\newblock {\em European Journal of Operational Research}, 188(3):617--636, 2008.

\bibitem{constraint_programming}
Rossi, F., van Beek, P., Walsh, T.
\newblock {\em Handbook of Constraint Programming}.
\newblock Elsevier, 2006.

\bibitem{mip_book}
Wolsey, L.A.
\newblock {\em Integer Programming}.
\newblock Wiley, 1998.

\bibitem{sat_handbook}
Biere, A., Heule, M., van Maaren, H., Walsh, T.
\newblock {\em Handbook of Satisfiability}.
\newblock IOS Press, 2009.

\bibitem{smt_survey}
Barrett, C., Sebastiani, R., Seshia, S.A., Tinelli, C.
\newblock {Satisfiability modulo theories}.
\newblock {\em Handbook of Satisfiability}, pages 825--885, 2009.

\bibitem{symmetry_breaking}
Crawford, J., Ginsberg, M., Luks, E., Roy, A.
\newblock {Symmetry-breaking predicates for search problems}.
\newblock {\em Principles of Knowledge Representation and Reasoning}, pages 148--159, 1996.

\bibitem{tournament_graphs}
Harary, F., Moser, L.
\newblock {The theory of round robin tournaments}.
\newblock {\em The American Mathematical Monthly}, 73(3):231--246, 1966.

\end{thebibliography}

\end{document}
